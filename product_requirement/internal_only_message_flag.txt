# Internal-Only Message Flag 기능

## 개요
completion_judge가 판단한 중간 메시지와 자동 생성된 사용자 메시지를 UI에서 숨기기 위한 기능

## 배경
- Orchestrator가 function call 없이 message만 반환할 때, completion_judge가 미션 완료 여부를 판단
- shouldComplete=false인 경우, 해당 assistant message는 중간 진행 상황이므로 사용자에게 표시하지 않음
- whatUserShouldSay를 통해 자동 생성된 user message도 실제 사용자 입력이 아니므로 표시하지 않음
- 하지만 이러한 메시지들은 orchestratorConversation에 저장되어 세션 복원 시 화면에 표시되는 문제 발생

## 요구사항

### 1. 숨겨야 할 메시지 유형
1. **Assistant 중간 메시지**: completion_judge가 shouldComplete=false로 판단한 assistant message
2. **자동 생성 User 메시지**: whatUserShouldSay로 생성된 가상의 user message

### 2. 동작 방식

#### 세션 진행 중
1. Orchestrator가 function call 없이 message 반환
2. Message를 출력하지 않고 대기 (pending)
3. completion_judge 호출하여 판단
4. **shouldComplete = true인 경우**:
   - Pending message를 화면에 출력
   - 세션 종료
5. **shouldComplete = false인 경우**:
   - Pending message를 출력하지 않음
   - orchestratorConversation에서 해당 assistant message에 `_internal_only: true` 플래그 추가
   - whatUserShouldSay가 있으면 다음 iteration의 improvement_points로 설정
   - improvement_points_is_auto_generated = true 플래그 설정
   - orchestrateMission 호출 시 isAutoGenerated 파라미터 전달
   - orchestrateMission에서 user message 생성 시 `_internal_only: true` 플래그 추가

#### 세션 복원 시 (-c, --continue 옵션)
1. session_memory.js의 reconstructUIHistory() 함수가 orchestratorConversation 읽음
2. 각 메시지 처리 시 `_internal_only` 플래그 확인
3. 플래그가 true인 메시지는 uiHistory에 추가하지 않음 (화면 표시 안 함)

### 3. 구현 상세

#### session.js
```javascript
// processOrchestratorResponses 함수 내
let pendingMessageOutput = null;  // 출력 대기 중인 MESSAGE 저장

// MESSAGE 처리 시 출력하지 않고 저장만
if (MESSAGE) {
    const { exeResult, content: msgContent } = processMessageOutput(output, false);
    pendingMessageOutput = output;
}

// completion_judge 판단
if (!executedFunctionCall && lastOutputType === 'message') {
    const judgement = await judgeMissionCompletion({ what_user_requests: mission });

    if (judgement.shouldComplete) {
        // 완료: pending message 출력
        if (pendingMessageOutput) {
            processMessageOutput(pendingMessageOutput, true);
        }
    } else {
        // 미완료: _internal_only 플래그 추가
        const conversation = getOrchestratorConversation();
        for (let i = conversation.length - 1; i >= 0; i--) {
            if (entry.type === 'message' && entry.role === 'assistant') {
                entry._internal_only = true;
                break;
            }
        }

        // whatUserShouldSay 처리
        if (judgement.whatUserShouldSay) {
            improvementPoints = judgement.whatUserShouldSay;
            improvementPointsIsAutoGenerated = true;
        }
    }
}

// runSession 메인 루프
let improvement_points_is_auto_generated = false;

orchestratedMission = await orchestrateMission({
    improvement_points: improvement_points,
    mcpToolSchemas: mcpToolSchemas,
    isAutoGenerated: improvement_points_is_auto_generated
});

improvement_points_is_auto_generated = false; // 리셋
```

#### orchestrator.js
```javascript
export async function orchestrateMission({
    improvement_points = '',
    mcpToolSchemas = [],
    isAutoGenerated = false
}) {
    const userMessage = {
        role: "user",
        content: [{ type: "input_text", text: improvementPointsText }]
    };

    // Auto-generated user message인 경우 플래그 추가
    if (isAutoGenerated) {
        userMessage._internal_only = true;
    }

    orchestratorConversation.push(userMessage);
}
```

#### session_memory.js
```javascript
// reconstructUIHistory 함수 내

// Assistant message 처리
if (item.type === 'message' && item.role === 'assistant' && item.content) {
    // _internal_only 플래그 확인
    if (item._internal_only) {
        debugLog('[reconstructUIHistory] Skipping assistant message with _internal_only flag');
        continue;
    }

    uiHistory.push({ type: 'assistant', text: text, timestamp: Date.now() });
}

// User message 처리
if (item.role === 'user' && item.content) {
    // _internal_only 플래그 확인
    if (item._internal_only) {
        debugLog('[reconstructUIHistory] Skipping user message with _internal_only flag');
        continue;
    }

    uiHistory.push({ type: 'user', text: textContent.text, timestamp: Date.now() });
}
```

### 4. 디버그 로깅
모든 _internal_only 플래그 관련 처리에 debug log 추가:
- `[_internal_only]` 접두사 사용
- 플래그 추가 시점, 이유, 대상 메시지 정보 기록
- 복원 시 건너뛴 메시지 정보 기록

## 기대 효과
1. 사용자는 완료된 최종 메시지만 보게 됨
2. 중간 진행 상황의 불필요한 메시지가 화면에 표시되지 않음
3. 자동 생성된 가상의 사용자 메시지가 표시되지 않음
4. 세션 복원 시에도 동일한 동작 보장
5. orchestratorConversation에는 모든 대화 내역 보존 (AI 처리용)

## 제약사항
- `_internal_only` 플래그는 UI 표시 제어만 담당
- orchestratorConversation에는 모든 메시지가 저장됨 (AI 컨텍스트 유지)
- 플래그는 세션 파일에 영구 저장됨
